产生怪物的有关逻辑:

1.level对象控制round责任链的执行。

2.具体产怪的逻辑是通过round去执行的，round里存有本回合需要产生的怪物数量与ID，之后会把这些内容传入GameController去调用Invoke方法延时
循环产生怪物。(为什么我们要把产怪方法封装在CameCOntoller里，而不是直接在round里去完成这个方法:1.我们要延时循坏调用方法InvokeRepeating，它是Mono里的方法。2.很多游戏逻辑类与信息存贮在GameController里，所以我们必须这样去设计)。

3.但在生成怪物的时候，会出现玩家暂停产生怪物去建塔或者得到礼物的情况，所以我们要通过调用GameController的停止方法去停止延时调用。并且我们想要随时去打开。暂停开关的监听我们要放在Update方法里。

4.我们每次调用产怪方法的时候都需要去判断一下当前产怪是否完成当次回合的产怪总数，完成则停止。否则让我们产怪索引去累加。


5.我们要即时监听玩家的杀怪数量。如果杀怪数量一旦等于我们当次回合怪物的总数，我们就调用level里的有关方法、把当前任务交给责任链的下一环，即进入下一个回合。每次调用Level有关方法的时候会判断我们的责任链是否到达最后一环，如果到达，则显示最后一波有关逻辑，如果超过，则游戏胜利。



炮塔搜索目标的有关逻辑：

一.怪物进入（Enter）

1.有集火目标

	但没找到集火目标
		1.找到的是物品且是集火目标
			锁定当前第一个进入检测区域的物品为攻击目标，有目标，是集火目标
		2.找到的是怪物
			1.且是集火目标
			锁定当前第一个进入检测区域的怪物为攻击目标，有目标，且是集火目标
			2.不是集火目标
			锁定当前第一个进入检测区域的怪物为攻击目标，有目标。

2.没有集火目标

	没有目标
		
		锁定当前第一个进入检测区域的怪物为攻击目标，有目标		


二.怪物滞留（Stay）

同上。

三.怪物离开（Exit）

如果当前检测区域的目标正是攻击的目标的时候，那么丢失目标，丢失集火目标，攻击目标为空。

